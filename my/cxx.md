# Խառը գրառումներ C++-ի մասին

## Տիպերին վերաբերող մի սխալի պատմություն

Ձելը բիլը տա՛կ։ Մի օր պարզվեց, որ մեր կոդի դասերից մեկում կա ժամանակային միավոր ներկայացնող մի անդամ, որի արժեքը ճիշտ չի ընթերցվում կոնֆիգուրացիայի ֆայլից։ Իրավիճակն ավելի լավ ներկայացնելու համար բերեմ պարզեցված C++ կոդը.

```C++
// կոնֆիգուրացիայի պարզեցված մոդելը
struct config {
    // ժամանակային ինտերվալը միլիվայրկյաններով
    int16_t intervalMs{0};
    // ինչ-որ տվյալների ինդեքս
    int16_t index{0};
    // ... և այլ
};
```

Այս կոդը ես էի գրել և, հավանաբար, անուշադրության պատճառով `intervalMs` անդամի տիպը թողել էի `int16_t`։ (Թե ինչու ժամանակային ինտերվալների համար չենք օգտագործում `std::chrono` անունների տիրույթի տիպերը՝ այլ խոսակցություն է։)

Այս ստրուկտուրայի առանձին դաշտերին արժեքներ վերագրելու համար սահմանված է մոտավորապես այսպիսի մի ֆունկցիա.

```C++
template<typename R>
void assign(R& place, const string& key, const json& data)
{
    if( const json_pointer jp{key}; data.contains(jp) )
        data.at(jp).get_as(place);
}

void read_config(config& cfg, const json& data)
{
    assign(cfg.intervalMs, "/interval-ms", data);
    assign(cfg.index, "/index", data);
}
```

Քանի դեռ կոնֆիգուրացիայում `interval-ms`-ն ուներ `int16_t` տիպում տեղավորվող արժեք, օրինակ, `12000`, ամեն ինչ լավ էր։ Օրինակ.

```C++
const auto example0 =
R"(
{
    "interval-ms": 12000,
    "index": 72
}
)"_json;
```

Բայց մի օր Հայկը կոնֆիգուրացիայում `interval-ms`-ի արժեքը դարձրեց `300000`, ու պարզվեց, որ ծրագիրը մեր սպասած վարքով չի աշխատում։ Կարճ ասած, սխալը գտանք, `intervalMs` անդամի տիպը փոխեցինք, ստուգեցինք, որ ամեն ինչ աշխատում է։ Ապահովության համար նորից անցանք կոնֆիգուրացիայի դասերի բոլոր այն անդամներով, որոնց անունն ունի `Ms` վերջածանցը ու համոզվեցինք, որ ուրիշ տեղ այդպիսի սխալ չունենք։

Ինչպե՞ս մեզ ապահվենք այս տիպի սխալներից։ Հայկը ոտի վրա ձևափոխեց `assign` ֆունկցիայի կաղապարն այնպես, որ ամբողջաթիվ տիպերի համար ստուգվի փոփոխականի գերհագեցումը (overflow): Մոտավորապես այսպես.

```C++
template<typename R>
void assign(R& place, const string& key, const json& data)
{
    if( const json_pointer jp{key}; data.contains(jp) ) {
        data.at(jp).get_to(place);

        if constexpr( is_integral_v<R> && !is_same_v<R, bool> ) {
            const auto vl = data.at(jp).get<uint64_t>();
            if( static_cast<int64_t>(place) != vl )
                throw runtime_error{"integer overflow detected"};
        }
    }
}
```

Սա մեզ հնարավորություն կտա կոնֆիգուրացիայի JSON ֆայլից տվյալները կարդալիս որսալ վերը նկարագրված սխալները։ Օրինակ, եթե մեր կոնֆիգուրացիան այսպիսինն է.

```json
const auto example2 = R"(
{
    "interval-ms": 300000,
    "count": 200
}
)"_json;
```

ապա հետևյալ կոդի կատարման արդյուքնում գեներացվելու է կատարման ժամանակի սխալ (`runtime_error`).

```C++
Config c;
assign(c.intervalMs, "/interval-ms", example2);
assign(c.count, "/count", example2);
```

Այս տիպի սխալներից խուսափելու համար ես առաջարկեցի մի փոքր այլ, թերևս նաև մի քիչ հումորային, լուծում։ Այն է՝ ընդլայնել clang-tydi գործիքի ստատիկ ստուգումների կանոններին ավելացնել ևս մեկը, որը կգտնի `Ms` վերջածանցն ունեցող բոլոր անդամ-փոփոխականները և կստուգի, որ դրանց տիպը `int` (`int32_t`) է։ ԼԼՎՄ-ի հետ ունեցած իմ աշխատանքային փորձը հուշում էր, որ դա շատ հեշտ բան պիտի լինի։

[LLVM](https://llvm.org/)—ի [GitHub](https://github.com/llvm) էջից պատճենում ենք `llvm-project` շտեմարանը.

```bash
$ git clone https://github.com/llvm/llvm-project.git
```
