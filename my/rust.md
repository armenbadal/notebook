# Խառը գրառումներ Rust-ի մասին

Ժամանակ առ ժամանակ փորձում եմ ծանոթանալ արդեն մոդայիկ [Rust](https://www.rust-lang.org) ծրագրավորման լեզվին։ Այս էջում պարբերաբար կգրեմ իմ փորձերի մասին։

## Առաջին ծրագիրը

Լեզվի իրականացումը տեղադրելուց հետո, բնականաբար, փորձեցի գրել ավանդական _hello, world_-ը։ Բայց քանի որ ինձ միշտ հետաքրքրում է, թե այս կամ այն ծրագրավորման լեզվում ինչպես են օգտագործվում _հայերեն_ տեքստերը (UTF-8 տեսքտերն ընդհանրապես), իմ ծրագիրը ստացավ հետևյալ տեսքը.

```Rust
fn main() {
    println!("Ճանաչել զիմաստութիւն եւ զխրատ, իմանալ զբանս հանճարոյ...")
}
```

Cargo-ով ստեղծեցի նոր պրոյեկտ. `cargo init hello-hy`, ու դրա `main.rs` ֆայլում գրեցի այս ծրագիրը։ Հետո աշխատեցրեցի `cargo run` հրամանով. սա նախ կոմպիլյացնում է գրած ծրագիրն ու ստեղծում է կատորվող մոդուլ, ապա կատարում է այն։ Իմ դեպքում ստացա այսպիսի արդյունք.

```
Ճանաչել զիմաստութիւն եւ զխրատ, իմանալ զբանս հանճարոյ...
```

Առայժմ ամեն ինչ ինձ գոհացնում է։


## Թվի արտահայտումը բառերով

Նոր ծրագրավորման լեզու սովորելիս ընտրում եմ խնդիրներ, որոնց ալգորիթմական լուծումն արդեն ունեմ ու փործում եմ այդ խնդիրը ծրագրավորել արդեն այլ լեզվով։ Այս դեպքում էլ վերցրել եմ _ամբողջ թվերը բառերով արտահայտելու_ հայտնի խնդիրը և ուզում եմ այն գրել Ռասթ լեզվով։ Հիշեցնեմ՝ պետք է իրականացնել ֆունկցիա, որը ստանում է թվի թվային տեսքը և վերադարձնում է դրա տեքստային արտահայտությունը։ Օրինակ, `219` թվից պետք է ստանալ «`երկու հարյուր տասնինը`» տեքստը։

Պարզության համար դիտարկենք մինչև վեցանիշ թվերը։ Ուսումնասիրելով թվերի տեքստային ներկայացումները կարելի է տեսնել, որ դրանք կազմված են _միավորների_ ու _տասնավորների_ անունների միակցումից, ինչպես նաև դրանց՝ «հարյուր» ու «հազար» բառերով շաղկապումներից։ Օրինակ, `528719` թվի տեքստային արտահայտությունը բաղկացած է `հազար` բառով իրար կապված երկու «միանման» արտահայտություններից. `հինգ հարյուր քսանութ` և `յոթ հարյուր տասնինը`։ Սրանցից ամեն մեկն էլ իր հերթին կազմված է `հարյուր` բառով իրար կապված միանիշ թվի անունից ու երկնիշ թվի արտահայտությունից։ Իսկ երկնիշ թվի արտահայտությունն էլ տաստանվորի ու միավորի անունների պարզ միակցում է։ արդեն պարզ է, չէ՞, որ կառուցելու եմ ռեկուրսիվ ֆունկցիա։ 

Իմ `number_in_words` ֆունկցիայի առաջին տարբերակն այսպիսինն էր։ 

```Rust
fn number_in_words(number: u32) -> String {
    if number < 10 {
        return ["", "մեկ", "երկու", "երեք", "չորս", "հինգ", "վեց", "յոթ", "ութ", "ինն"][number as usize].to_string()
    }

    if number < 100 {
        let t = ["", "տաս", "քսան", "երեսուն", "քառասուն", "հիսուն", "վաթսուն", "յոթանասուն", "ութսուն", "իննսուն"][(number / 10) as usize].to_string();
        return [t, number_in_words(number % 10)].concat()
    }

    if number < 1000 {
        let h = number_in_words(number / 100);
        let t = number_in_words(number % 100);
        return [h, t].join(" հարյուր ")
    }

    let h = number_in_words(number / 1000);
    let t = number_in_words(number % 1000);
    return [h, t].join(" հազար ")
}
```

Պատկերացնում եմ, թե որքան ծիծաղելի կերևա այն փորձառու Ռասթ-ծրագրավորողների աչքին։ այնուամենայնիվ, թեև սա այնքան էլ նման չէ Ռասթ ոճով գրված ծրագրի, այն իր խնդիրը կատարում է։ Կարող եմ ցույց տալ։ Այսպես.

```Rust
fn main() {
    assert_eq!("երեք հարյուր քսանմեկ հազար ութ հարյուր յոթանասունվեց", number_in_words(321876))
}
```

Հաջորդ երկու կարևոր կետերը, որ սովորեցի, հետևյալներն են. ա) ֆունկցիայում վերջին հաշվարկվաշ արժեքը համարվում է ֆունկցիայի վերադարձրած արժեք, բ) `if`-ը կարելի է գրել և որպես հրաման, և որպես արտահայտություն։ Հետևաբար, `number_in_words` ֆունկցիայի մի քիչ լավացրած տարբերակը կարող է լինել այսպիսին.


```Rust
fn number_in_words(number: u32) -> String {
    if number < 10 {
        ["", "մեկ", "երկու", "երեք", "չորս", "հինգ", "վեց", "յոթ", "ութ", "ինն"][number as usize].to_string()
    }
    else if number < 100 {
        let t = ["", "տաս", "քսան", "երեսուն", "քառասուն", "հիսուն", "վաթսուն", "յոթանասուն", "ութսուն", "իննսուն"][(number / 10) as usize].to_string();
        [t, number_in_words(number % 10)].concat()
    }
    else if number < 1000 {
        let h = number_in_words(number / 100);
        let t = number_in_words(number % 100);
        [h, t].join(" հարյուր ")
    }
    else {
        let h = number_in_words(number / 1000);
        let t = number_in_words(number % 1000);
        [h, t].join(" հազար ")
    }
}
```

Հեռացրել եմ `return`-ները և `if`-ը դարձրել եմ արտահայտություն։ Բայց հենց նույն ժամանակ էլ տեսա, որ այս և նմանատիպ դեպքերում ավելի հարմար է օգտագործել ոչ թե `if` կառուցվածքը, այլ `match`-ը։ Վերջինս, ինչպես երևում է անունից, վերցնում է որևէ արժեք և փորձում է այն համապատասխանեցնել իր մարմնում սահմանված ճյուղերից որևէ մեկին։ Նորից եմ ձևափոխում `number_in_words` ֆունկցիան.

```Rust
fn number_in_words(number: u32) -> String {
    match number {
        0..=9 => {
            ["", "մեկ", "երկու", "երեք", "չորս", "հինգ", "վեց", "յոթ", "ութ", "ինը"][number as usize].to_string()
        },
        10..=99 => {
            let denary = ["", "տաս", "քսան", "երեսուն", "քառասուն", "հիսուն", "վաթսուն", "յոթանասուն", "ութսուն", "իննսուն"][(number / 10) as usize].to_string();
            [denary, number_in_words(number % 10)].concat()
        },
        100..=999 => {
            let h = number_in_words(number / 100);
            let t = number_in_words(number % 100);
            [h, t].join(" հարյուր ")
        },
        _ => {
            let h = number_in_words(number / 1000);
            let t = number_in_words(number % 1000);
            [h, t].join(" հազար ")
        }
    }
}
```

Այս ձևափոխություններից հետո նորից մի քանի ստուգումներ ավելացրեցի ու պարզեցի, որ ինչ-որ դեպքերում ստանում եմ սխալ արդյունքներ։ Օրինակ, `10` թվի համար `տասը` բառի փոխարեն ստանում եմ `տաս`, կամ `19` թվի համար ստանում եմ `տասինը`, այլ ոչ թե `տասնինը`։ Հերթական ձևափոխության մեջ ուղղելու եմ այս թերությունը, բայց մինչ այդ կոդը տրոհեմի մի քանի ֆունկցիաների։

Միանիշ թվերի համար սահմանում եմ `single_digit` ֆունկցիան.

```Rust
fn single_digit(number: u32) -> String {
    ["", "մեկ", "երկու", "երեք", "չորս", "հինգ", 
    "վեց", "յոթ", "ութ", "ինը"][number as usize].to_string()
}
```

Երկնիշ թվերի համար՝ `two_digits`-ը.

```Rust
fn two_digits(number: u32) -> String {
    let denary = ["", "տաս", "քսան", "երեսուն", "քառասուն",
        "հիսուն", "վաթսուն", "յոթանասուն", "ութսուն", "իննսուն"
    ][(number / 10) as usize].to_string();
    [denary, number_in_words(number % 10)].concat()
}
```

`match` կառուցվածքի երրորդ ու չորրորդ ճյուղերում գրված է իրար շատ նման տեքստ. դա էլ եմ սահմանել որպես առանձին ֆունկցիա։

```Rust
fn compose(number: u32, limit: u32, sep: &str) -> String {
    let h = number_in_words(number / limit);
    let t = number_in_words(number % limit);
    [h, t].join(sep)   
}
```

Այսքանից հետո արդեն `number_in_words` ֆունկցիան ստանում  է հետևյալ սեղմ տեքստը.

```Rust
fn number_in_words(number: u32) -> String {
    match number {
        0..=9 => single_digit(number),
        10..=99 => two_digits(number),
        100..=999 => compose(number, 100, " հարյուր "),
        _ =>  compose(number, 1000, " հազար ")
    }
}
```

Հիմա խմբագրեմ `two_digits` ֆունկցիան ու ուղղեմ `10` թվի բառային արտահայտության հետ կապված թերությունը։ Մի քանի փորձերից հետո ստացա հետևյալը.

```Rust
fn two_digits(number: u32) -> String {
    let unit = number_in_words(number % 10);

    let mut denary = ["", "տասն", "քսան", "երեսուն", 
        "քառասուն", "հիսուն", "վաթսուն", "յոթանասուն", 
        "ութսուն", "իննսուն"][(number / 10) as usize].to_string();
    if denary == "տասն" && unit.is_empty() {
        denary = "տասը".to_string()
    }

    [denary, unit].concat()
}
```

Այսքանը _թիվը բառերով արտահայտող_ ծրագրի իրականացման մասին։ Թեսթավորմանս մասին, ինչպես ասում էր դասականը, հաջորդ դասին։


## Թեսթավորում. unit testing

Ռասթ պրոյեկտում unit test֊երը գրվում են `tests` անունով մոդուլում, որոնք նշվում են `#[cfg(test)]` պիտակով։ Օրինակ, թվերը բառերով արտահայտելու ծրագրի `main.rs` ֆայլում կարող ենք սահմանել այսպիսի մոդուլ. 

```Rust
#[cfg(test)]
mod tests {
    // ... 
}
```

Այս մոդուլում արդեն առանձին թեսթերը պետք է սահմանել որպես սովորական ֆունկցիաներ՝ պարզապես նշելով `#[test]` պիտակով։ Օրինակ, `single_digit` ֆունկցիայի համար կարելի է գրել.

```Rust
    // ...
    #[test]
    fn test_single_digit() {
        assert_eq!("", single_digit(0));
        assert_eq!("մեկ", single_digit(1));
        assert_eq!("ինը", single_digit(9))
    }
    // ...
```

Նույն կերպ կարելի է, և պետք է, թեսթեր գրել ծրագրի մյուս ֆունկցիաների համար։ Ես գրեմ նաև `number_in_words` ֆունկցիայի համար.

```Rust
    // ...
    #[test]
    fn test_number_in_words() {
        assert_eq!("մեկ", number_in_words(1));
        assert_eq!("տասնմեկ", number_in_words(11));
        assert_eq!("մեկ հարյուր տասնմեկ", number_in_words(111));
        assert_eq!("չորս հարյուր հիսունյոթ", number_in_words(457));
        assert_eq!("երկու հազար չորս հարյուր հիսունյոթ", number_in_words(2457));
        assert_eq!("երեսունինը հազար չորս հարյուր հիսունյոթ", number_in_words(39457));
        assert_eq!("յոթ հարյուր ութսունինը հազար չորս հարյուր հիսունյոթ", number_in_words(789457))    
    }
    // ...
```

Թեսթավորման մասին պետք է խոսել միշտ ու շատ։ Դրա համար էլ՝ հիմա բավարարվենք այսքանով, իսկ հաջորդ դխնդիրները ներկայացնելիս ու քննարկելիս էլ սովորություն դարձնենք միշտ թեսթեր գրել։
