# Լամբդաների զարգացումը C++14-ում, C++17-ում և C++20-ում

(Թարգմանված է [The Evolutions of Lambdas in C++14, C++17 and C++20](https://www.fluentcpp.com/2021/12/13/the-evolutions-of-lambdas-in-c14-c17-and-c20/))

_Հրապարակված է 13 դեկտեմբերի 2021_

Լամբդաները ժամանակակից C++-ի ամենահանրաճանաչ հատկություններից մեկն են։ C++11-ում իրենց ներմուծումից ի վեր դրանք համատարած են դարձել C++ կոդում։

Բայց հենց C++11-ում ներմուծվելուց հետո դրանք զարգացել են և օժտվել են կարևոր հատկություններով։ Այդ հատկություններից որոշներն օգնում են գրել ավելի արտահայտիչ կոդ, և քանի որ այսօր լամբդաների օգտագործումը սովորական բան է, արժե ժամանակ ծախսել սովորելու համար, թե ինչ կարող ենք անել դրանց միջոցով։

Այստեղ մեր նպատակն է պրազաբանել լամբդաների հիմնական զարգացման ուղղությունները, բայց ոչ մանրուքները։ Լամբդաների ընդգրկուն լուսաբանումը ավելի հարմար կլինի գրքի համար, քան հոդվածի։ Եթե ուզում եք ավելի խորանալ, ապա ես խորհուրդ կտամ Բարթեքի (Bartek) [C++ Lambda Story](https://leanpub.com/cpplambda) գիրքը, որը ձեզ կպատմի ամեն ինչի մասին:

Լամբդաների հիմնական զարգացումը գնացել է այն ուղղությամբ, որ դրանք օժտվեն սովորական եղանակով սահմանված ֆունկցիա-օբյեկտներ հատկություններով։

Այս հոդվածում ենքադրում ենք, որ դուք ծանոթ եք C++11-ի լամբդաների հիմունքներին։ Ուրեմն սկսենք C++14-ից։


## C++14-ի լամբդաները

C++14-ում լամբդաները ստացան չորս գլխավոր բարելավումներ.
* լռելության արժեքով պարամետրեր,
* կաղապարների պարամետրեր,
* ընդհանրացված capture (կալանում?),
* լամբդայի վերադարձնելը ֆունկցիայից։


### Լռելության արժեքով պարամետրեր

C++14-ում լամբդաները, ինչպես և ցանկացած ֆունկցիա, կարող են ունենալ լռելության արժեքով պարամետրեր.

```C++
auto myLambda = [](int x, int y = 0){ std::cout << x << '-' << y << '\n'; };

std::cout << myLambda(1, 2) << '\n';
std::cout << myLambda(1) << '\n';
```

Այս կոդն արտածում է հետևյալը.

```
1-2
1-0
```

### Կաղապարների պարամետրեր

C++11-ում մենք պետք է բացահայտ սահմանեինք լամբդայի պարամետրերի տիպը.

```C++
auto myLambda = [](int x){ std::cout << x << '\n'; };
```

C++14-ում կարող ենք այնպես անել, որ դրանք ընդունեն ցանկացած տիպ.

```C++
auto myLambda = [](auto&& x){ std::cout << x << '\n'; };
```
Նույնիսկ եթե դուք մի քանի տիպերի հետ չեք աշխատելու, սա կարող է օգտակար լինել կրկնություններից խուսափելու համար և կոդը դարձել ավելի սեղմ ու ընթեռնելի։ Օրինակ, հետևյալ լամբդան.

```C++
auto myLambda = [](namespace1::namespace2::namespace3::ACertainTypeOfWidget const& widget) { std::cout << widget.value() << '\n'; };
```

վերածվում է սրան.

```C++
auto myLambda = [](auto&& widget) { std::cout << widget.value() << '\n'; };
```

### Ընդհանրացված capture (կալանում?)

C++11-ում լամբդաները կարող են կալանել իրենց տեսանելիության տիրույթում գոյություն ունեցող օբյեկտները.

```C++
int z = 42;
auto myLambda = [z](int x){ std::cout << x << '-' << z + 2 << '\n'; };
```

Բայց ավելի զորեղ ընդհանրացված կալանման միջոցով կարող ենք կալանված արժեքները սկզբնարժեքավորել համարյա ցանկացած արժեքով։ Ահա մի պարզ օրինակ.

```C++
int z = 42;
auto myLambda = [y = z + 2](int x){ std::cout << x << '-' << y << '\n'; };

myLambda(1);
```

Այս կոդը արտածում է հետևյալը.

```
1-44
```


### Լամբդայի վերադարձնելը ֆունկցիայից

Լամբդաներն օգտվում են C++14-ի՝ ֆունկցիայից, առանց վերադարձվող արժեքի տիպը բացահայտ նշելու, `auto` վերադարձնելու հատկությունից։ Քանի որ լամբդայի տիպը գեներացվում է կոմպիլյատորի կողմից, C++11-ում մենք չէինք կարող ֆունկցիայից լամբդա վերադարձնել.

```C++
/* ի՞նչ տիպ պետք է գրվի այստեղ */ f()
{
    return [](int x){ return x * 2; };
}
```

C++14-ում կարող ենք լամբդա վերադարձնել՝ որպես վերադարձվող արժեքի տիպ նշելով `auto`-ն։ Սա օգտակար է այն դեպքում, երբ կոդի մի հատվածում հանդիպում է մեծ լամբդա.

```C++
void f()
{
    // ...
    int z = 42;
    auto myLambda = [z](int x)
                    {
                        // ...
                        // ...
                        // ...
                    };
    // ...
}
```

Կարող ենք լամբդան «փաթեթավորել» մի այլ ֆունկցիայի մեջ՝ դրանով ներմուծելով վերացականացման ևս մի մակարդակ.

```C++
auto getMyLambda(int z)
{
    return [z](int x)
           {
               // ...
               // ...
               // ...
           };
}

void f()
{
    // ...
    int z = 42;
    auto myLambda = getMyLambda(z);
    // ...
}
```

Այս հնարքի մասին ավելին իմանալու համար ուսումնասիրեք [out-of-line lambdas](https://www.fluentcpp.com/2020/06/05/out-of-line-lambdas/) հետաքրքիր հոդվածը։


## C++17-ի լամբդաները

Լամբդաների համար C++17-ը բերեց մի կարևոր բարելավում. դրանք կարող են հայտարարվել որպես `constexpr`.

```C++
constexpr auto times2 = [] (int n) { return n * 2; };
```

Այսպիսի լամբդաներն այնուհետև կարող են օգտագործվել կոմպիլյացիայի ժամանակ հաշվարկվող համատեքստում.

```C++
static_assert(times2(3) == 6);
```

Սա, մասնավորապես, օգտակար է կաղապարներ ծրագրավորելիս։

Նկատենք սակայն, որ `constexpr` լամբդաները առավել օգտակար դարձան C++20-ում։ Իսկապես, միայն C++20-ում `std::vector`-ը և STL-ի շատ ալգորիթմներ նույնպես դարձան `constexpr`, և դրանք կարող են `constexpr` լամբդաների հետ օգտագործվել՝ կոմպիլյացիայի ժամանակ հաշվարկվող հավաքածուների հետ բարդ գործողություններ կատարելու համար։

Սակայն այս տեսակետից բացառություն է `std::array` կոնտեյները։ `std::array`-ի չփոփոխող (non-mutuating) մատչման գործողությունները `constexpr` դարձան հենց C++14-ից սկսած, իսկ դրանց փոփոխոող տարբերակները՝ C++17-ից։


### *this-ի պատճենի capture-ը

Մի այլ հատկություն, որով լամբդաներն օժտվեցին C++17-ում, `*this`-ի պատճենը վերցնելու պարզ քերականությունն է։ Դա ցուցադրելու համար դիտարկենք հետևյալ օրինակը.

```C++
struct MyType{
    int m_value;
    auto getLambda()
    {
        return [this](){ return m_value; };
    }
};
```

Այս լամբդան վերցնում է `this`-ի՝ ցուցիչի պատճենը։ Սա կարող է բերել հիշողության հետ կապված սխալների, եթե լամբդան ավելի երկար է ապրում քան օբյեկտը, օրինակ, հետևյալ դեպքում.

```C++
auto lambda = MyType{42}.getLambda();
lambda();
```

Երկրորդ հրամանում լամբդայի կանչը ապահասցեավորում է `this`-ը՝ դրա `m_value`-ն ստանալու համար, բայց քանի որ `MyType`-ի օբյեկտը ոչնչացվում է առաջին հրամանի վերջում, իսկ, ապա ստացվում է, որ `this`-ը ցույց է տալիս ոչնչացված օբյեկտի։ Սա բերում է անորոշ վարքի (undefined behavior), որպես հետևանք՝ ծրագրի չնախատեսված ավարտի։

Խնդրի հնարավոր լուծումներից մեկը լամբդայի կողմից ամբողջ օբյեկտի պատճենը վերցնելն է։ Դրան հասնելու համար C++17-ն առաջարկում է հետևյալ քերականությունը (ուշադրություն դարձրեք `this`-ից առաջ գրված `*`-ին).

```C++
struct MyType
{
    int m_value;
    auto getLambda()
    {
        return [*this](){ return m_value; };
    }
};
```

Նշենք, որ նույն արդյունքին կարելի էր հասնել արդեն C++14-ում՝ ընդհանրացված capture-ի միջոցով.

```C++
struct MyType
{
    int m_value;
    auto getLambda()
    {
        return [self = *this](){ return self.m_value; };
    }
};
```

C++17-ը պարզապես առաջարկում է ավելի գեղեցիկ գրելաձև։


## C++20-ի լամբդաները

Լամբդաները C++20-ում էլ են զարգացել, բայց թերևս նվազ հիմնարար հատքություններով, քան C++14-ում կամ C++17-ում։

C++20-ում արված բարելավումներից մեկը, որը դրանց ավելի է մոտեցնում սովորական եղանակով սահմանված ֆունկցիա-օբյեկտներին, դա կաղապարների սահմանման դասական գրելաձևն է.

```C++
auto myLambda = []<typename T>(T&& value){ std::cout << value << '\n'; };
```

Սա ավելի է հեշտացնում կաղապարի պարամետրի տիպի հասանելիությունը, քան C++14-ի լամբդաների համար, որոնք օգտագործում էին `auto&&`-ի պես արտահայտություններ։

Մի այլ բարելավում է վարիադիկ պարամետրերի փաթեթ վերցնելու հնարավորությունը.

```C++
template<typename... Ts>
void f(Ts&&... args)
{
    auto myLambda = [...args = std::forward<Ts>(args)](){};
}
```


## Ավելին՝ լամբդաների մասին

Մենք դիտարկեցինք այն ամենը, ինչ ես համարում եմ լամբդաների գլխավոր բարելավումներ C++14-ում և C++20-ում։ Բայց սա դեռ ամենը չէ։ Այս կարևոր հատկություններն ուղեկցվում են նաև որոշ մանր հատկություններով, որոնց շնորհիվ լամբդայի կոդ գրելն ավելի է հեշտանում։

Լամբդաների մասին ավելի իմանալը լավ հնարավորություն է C++ լեզուն ավելի լավ հասկանալու համար, և ես կարծում եմ, որ արժեք դրա համար ժամանակ ծախսել։ Առաջ գնալու համար իմ իմացած լավագույն աղբյուրը Բարթեքի [C++ Lambda Story](https://leanpub.com/cpplambda) գիրքն է, որը ես խորհուրդ տվեցի վերևում։
