
# (Ինչպես գրել (Lisp լեզվի) ինտերպրետատոր (Python լեզվով))

Այս էջն ունի երկու նպատակ․ նկարագրել, թե ինչպես կարելի է իրականացնել ծրագրավորման լեզվի ինտերպրետատորն ընդհանրապես, և ինչպես իրականացնել Lisp լեզվի դիալեկտ Scheme լեզվի ենթաբազմությունը Python լեզվով։ Ես իմ ինտերպրետատորն անվանել եմ Lispy (lis.py): Մի քանի տարի առաջ ես ցույց տվեցի, թե ինչպես գրել Scheme-ի ինտերպրետատորը Java լեզվով, ինչպես նաև Common Lisp լեզվով։ Այս անգամ իմ նպատակն է հնարավորինս համառոտ ու մատչելի ցույց տալ, թե ի՞նչն էր Ալան Քեյն (Alan Kay) անվանում «Ծրագրավորման Մաքսվելի հավասարումներ»։ (Եթե ձեզ դուր եկավ այս մեջբերումը, ապա կարող եք կարդալ նաև հետևյալ շարադրանքը՝ ավելի ամբողջական ինտերպրետատորի մասին։)


## Scheme-ի ենթաբազմություն Lispy լեզվի շարահյուսությունն ու սեմանտիկան

Շատ ծրագրավորման լեզուներ ունեն տարատեսակ շարահյուսական կառուցվածքներ (ծառայողական բառեր, ինֆիքսային օպերատորներ, փակագծեր, օպերատորների նախապատվություն, կետային-գրառում, կետ-ստորակետ և այլն), բայց որպես լեզուների Lisp ընտանիքի անդամ, Scheme-ի շարահյուսությունը հիմնված է փակագծերի մեջ առնված պրեֆիքսային գրառմամբ ցուցակների վրա։ Սա կարող է անսովոր թվալ, բայց այն ունի պարզության և միատեսակության առավելությունը։ (Երբեմն կատակում են, որ Lisp անվանումը նշանակում է «Lots of Irritating Silly Parentheses», ես կարծում եմ, որ Lisp նշանակում է «Lisp Is Syntactically Pure»։) Դիտարկենք հետևյալը․

````
Java
if (x.val() > 0) { 
  z = f(a * x.val() + b[i]); 
}

Scheme
(if (> (val x) 0) 
    (set! z (f (+ (* a (val x)) 
                  (aref b i)))))
````

ՈՒշադրություն դարձրեք, որ բացականչական նշանը Scheme-ի հատուկ սիմվոլ չէ, այն պարզապես «set!» անունի մաս է։ Միայն փակագծերն են հատուկ սիմվոլներ։ (set! x y) տեսքի ցուցակները, որոնց առաջին դիրքում հատուկ ծառայողական բառ է, Sceme-ում կոչվում են հատուկ կառուցվածքներ․ լեզվի հմայքն այն է, որ մեզ անհրաժեշտ է ընդհամենը վեց հատուկ կառուցվածքներ, դրան գումարած երեք այլ քերականական կառուցվածքներ՝ փոփոխականները, հաստատունները և պրոցեդուրաների կանչերը․

+--------------------+----------------------+-----------------------------------------------------+
| variable reference | var                  | Սիմվոլը մեկնաբանվում է որպես փոփոխականի անուն, իսկ  |
|                    |                      | նրա արժեքը՝ որպես փոփոխականի արժեք։ Օրինակ, x       |
+--------------------+----------------------+-----------------------------------------------------+
| constant literal   | թիվ                  | թվի հաշվարկված արժեքը հենց ինքն է։                  |
|                    |                      | Օրինակ, 12 կամ -3.45e+6                             |
+--------------------+----------------------+-----------------------------------------------------+
| quotation          | (quote exp)          | Վերադարձնում է exp-ը առանց հաշվարկելու։             |
|                    |                      | Օրինակ, (quote (a b c)) => (a b c)                  |
+--------------------+----------------------+-----------------------------------------------------+
| conditional        | (if test conseq alt) | Հաշվրկել test-ը, եթե ճշմարիտ է, ապա հաշվարկել և     |
|                    |                      | վերադարձնել conseq-ը, հակառակ դեպքում հաշվարկել և   |
|                    |                      | վերադարձնել alt-ը։                                  |
|                    |                      | Օրինակ, (if (< 10 20) (+ 1 1) (+ 3 3)) => 2         |
+--------------------+----------------------+-----------------------------------------------------+
| assignment         | (set! var exp)       | Հաշվարկել exp-ը և արժեքը վերագրել var-ին, որը պետք  |
|                    |                      | է նախապես հայտարարված լինի (define-ի միջոցով, կամ   |
|                    |                      | որպես ներառող պրոցեդուրայի պարամետր)։               |
|                    |                      | Օրինակ, (set! x2 (* x x))                           |
+--------------------+----------------------+-----------------------------------------------------+
| definition         | (define var exp)     | Սահմանել նոր փոփոխական ամենաներսի միջավայրում և նրան|
|                    |                      | վերագրել exp արտահայտության հաշվարկման արդյունքը։   |
|                    |                      | Օրինակ, (define r 3) կամ (define square             |
|                    |                      | (lambda (x) (* x x)))                               |
+--------------------+----------------------+-----------------------------------------------------+
| procedure          | (lambda (var...) exp)| Ստեղծել var... պարամետր(եր)ով և exp մարմնով         |
|                    |                      | պրոցեդուրա։ Օրինակ,                                 |
|                    |                      | (lambda (r) (* 3.141592653 (* r r)))                |
+--------------------+----------------------+-----------------------------------------------------+
| sequencing         | (begin exp...)       | Ձախից-աջ հաշվարկել արտահայտությունները և վերադարձնել|
|                    |                      | վերջինի արժեքը։ Օրինակ, (begin (set! x 1)           |
|                    |                      | (set! x (+ x 1)) (* x 2)) => 4                      |
+--------------------+----------------------+-----------------------------------------------------+
| procedure call     | (proc exp...)        | Եթե proc-ը if, set!, define, lambda, begin կամ quote|
|                    |                      | սիմվոլներից տարբերվող անուն է, ապա այն մեկնաբանվում |
|                    |                      | է որպես պրոցեդուրայի անուն։ Այն հաշվարկվում է այստեղ|
|                    |                      | սահմանված նույն կանոններով։ Բոլոր exp...            |
|                    |                      | արտահայտությունները հաշվարկվում են և proc           |
|                    |                      | պրոցեդուրան կանչվում է այդ արգումենտներով։          |
|                    |                      | Օրինակ, (square 12) => 144                          |
+--------------------+----------------------+-----------------------------------------------------+

Այս աղյուսակում var-ը պետք է լինի սիմվոլ՝ իդենտիֆիկատոր, որպիսիք են x-ը կամ square-ը, և number-ը պետք է լինի ամբողջ կամ սահող կետով թիվ, իսկ մյուս շեղ գրված բառերը կարող են լինել կամայական արտահայտություններ։ exp... գրառումը նշանակում է exp-ի զրո կամ ավել կրկնություն։

Scheme լեզվի մասին ավելի մանրամասն տեղեկություններ են պարունակում մի քանի հրաշալի գրքեր (Friedman and Fellesein, Dybvig, Queinnec, Harvey և Wright կամ Sussman և Abelson), տեսանյութեր (Abelson and Sussman), դասագրքեր (Dorai, PLT, կամ Neller), կամ ուղեցույցը։


## Ի՞նչ գործ է անում լեզվի ինտերպրետատորը

Ծրագրավորման լեզվի ինտերպրետատորը բաղկացած է երկու մասերից․

  1․ Վերլուծում։ Վերլուծող մասն իր մուտքում ստանում է ծրագիրը որպես սիմվոլների հաջորդականություն, ստուգում է դրանց համապատասխանությունը լազվի շարահյուսական կանոններին և ծրագիրը թարգմանում է ինտերպրետատորի ներքին ներկայացման։ Պարզ ինտերպրետատորում ներքին ներկայացումը ծառաձև կառուցվածք է, որն արտապատկերում է ծրագրի հրամանների ու արտահայտությունների ներդրված կառուցվածքը։ Ծրագրավորման լեզվի թարգմանիչում, որը կոչվում է կոմպիլյատոր, ներքին ներկայացումը հրամանների հաջորդականություն է, որը կարող է անմիջականորեն կատարվել համակարգչի կողմից։ Lispy լեզվի վերլուծող մասը (parser) իրականացված է parse ֆունկցիայով։

  2․ Կատարում։ Հաջորդ քայլերում ներքին ներկայացումը մշակվում է ըստ լեզվի սեմանտիկ կանոնների, դրանով իսկ իրականացնելով հաշվարկումը։ Կատարող մասն իրականացված է eval ֆունկցիայով (պետք է նկատի ունենալ, որ սա ստվերում է Python-ի ներդրված ֆունկցիան)։

Ստորև բերված է ինտերպրետացիայի պրոցեսի գծապատկերը, և ինտերակտիվ աշխատանքի մի հատված, որը ցույց է տալիս, թե ինչպես են աշխատում parse և eval ֆունկցաիները կարճ ծրագրի վրա․

program -> PARSER -> representation -> EXECUTION -> output

````
>> program = "(begin (define r 3) (* 3.141592653 (* r r)))"

>>> parse(program)
['begin', ['define', 'r', 3], ['*', 3.141592653, ['*', 'r', 'r']]]

>>> eval(parse(program))
28.274333877
````

Այստեղ օգտագործում ենք պարզագույն ներքին ներկայացում, որտեղ Scheme-ի ցուցակները, թվերը և սիմվոլները համապատասխանաբար ներկայացված են Python-ի ցուսակներով, թվերով և տողերով։


Կատարում․ eval
-------------

Ահա eval ֆունկցիայի սահմանումը։ Ստորև բերված կոդի ամեն մի ճյուղում գրված է մեկ, երկու կամ երեք տող, և eval ֆւնկցիան սահմանելու համար ոչինչ պետք չէ, բացի այս ինը ճյուղերը․

````
def eval(x, env=global_env):
    "Evaluate an expression in an environment."
    if isa(x, Symbol):             # variable reference
        return env.find(x)[x]
    elif not isa(x, list):         # constant literal
        return x                
    elif x[0] == 'quote':          # (quote exp)
        (_, exp) = x
        return exp
    elif x[0] == 'if':             # (if test conseq alt)
        (_, test, conseq, alt) = x
        return eval((conseq if eval(test, env) else alt), env)
    elif x[0] == 'set!':           # (set! var exp)
        (_, var, exp) = x
        env.find(var)[var] = eval(exp, env)
    elif x[0] == 'define':         # (define var exp)
        (_, var, exp) = x
        env[var] = eval(exp, env)
    elif x[0] == 'lambda':         # (lambda (var*) exp)
        (_, vars, exp) = x
        return lambda *args: eval(exp, Env(vars, args, env))
    elif x[0] == 'begin':          # (begin exp*)
        for exp in x[1:]:
            val = eval(exp, env)
        return val
    else:                          # (proc exp*)
        exps = [eval(exp, env) for exp in x]
        proc = exps.pop(0)
        return proc(*exps)

isa = isinstance

Symbol = str
````

Սա ամենն է հաշվարկումն անելու համար․․․ լավ, թերևս բացի միջավայրերը (environment):

Կատարման միջավայրեր
-------------------

Կատարման միջավայրերն ընդհամենը արտապատկերումներ են սիմվոլների և նրանց արժեքների միջև։ Նոր `symbol/value` կապը միջավայրում ավելացվում է `define`-ի կամ պրոցեդուրայի սահմանման (`lambda` արտահայտություններ) միջոցով։

Օրինակի վրա տեսնենք, թե ի՞նչ է կատարվում, երբ սահմանում, ապա կանչում ենք Scheme պրոցեդուրան (`lis.py>` հուշումը ցույց է տալիս, որ խոսում ենք ոչ թե Python-ի այլ Lisp-ի ինտերպրետատորի հետ)․

````
lis.py> (define area (lambda (r) (* 3.141592653 (* r r))))
lis.py> (area 3)
28.274333877
````

Երբ հաշվարկում ենք `(lambda (r) (* 3.141592653 (* r r)))` արտահայտությունը, մենք դիտարկում ենք `eval` ֆունկցիայի `elif x[0] == 'lambda'` ճյուղը, որտեղ `(_, vars, exp)` երեք փոփոխականներին վերագրվում են `x` ցուցակի համապատասխան տարրերը (և տեղեկացնում ենք սխալի մասին, եթե `x` ցուցակի երկարությունը 3-ից պակաս է)։ Ապա ստեղծում ենք նոր պրոցեդուրա, որը կանչելիս պետք է հաշվարկի `['*', 3.141592653 ['*', 'r', 'r']]` արտահայտությունը մի միջավայրում, որը ձևավորվում է պրոցեդուրայի ֆորպալ պարամետրերը (այս դեպքում դա միակ `r` պարամետրն է) կապելով պրոցեդուրայի կանչի ժամանակ տրված արգումենտներին, ինչպես նաև օգտագործելով ընթացիկ միջավայրն այն փոփոխականների համար, որոնք պարամետրերի ցուցակից չեն (օրինակ, `*` փոփոխականը)։ Այս նոր ստեղծված պրոցեդուրան այնուհետև կապվում է `global_env` միջավայրի `area` փոփոխականի հետ։

Իսկ ի՞նչ է կատարվում, երբ հաշվարկում ենք `(area 3)`։ Քանի որ `area`-ն հատուկ կառուցվածքների սիմվոլներից որևէ մեկը չէ, ապա սա պիտի լինի պրոցեդուրայի կանչ (`eval`-ի վերջին `else:` ճյուղը) և հերթով պետք է հաշվարկել ցուցակի տարրերը։ `area` սիմվոլի հաշվարկը վերադարձնում է այն պրոցեդուրան, որ քիչ վերևում սահմանեցինք, `3` սիմվոլի հաշվարկը վերադարձնում է 3 արժեքը։ Այնուհետև, ըստ `eval` ֆունկցիայի վերջին տողի, կանչում ենք այդ նոր ստեղծած պրոցեդուրան, նրան որպես արգումենտ փոխանցելով `[3]` ցուցակը։ Սա նշանակում է `['*', 3.141592653 ['*', 'r', 'r']]` ցուցակը հաշվարկել մի կատարման միջավայրում, որտեղ `r`-ն ունի 3 արժեքը, իսկ այդ միջավայրի համար արտաքին է գլոնալ կատարման միջավայրը, հետևաբար `*`-ը բազմապատկման պրոցեդուրան է։

Հիմա արդեն պատրաստ ենք բացատրելու

````
class Env(dict):
    "An environment: a dict of {'var':val} pairs, with an outer Env."
    def __init__(self, parms=(), args=(), outer=None):
        self.update(zip(parms,args))
        self.outer = outer
    def find(self, var):
        "Find the innermost Env where var appears."
        return self if var in self else self.outer.find(var)
````


