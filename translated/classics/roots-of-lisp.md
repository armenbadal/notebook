# Լիսպ լեզվի արմատները

_The Roots of Lisp_  
_Paul Graham_  
_Draft, January 18, 2002._  

1960 թվականին Ջոն ՄակՔարթին (John Mccarthy) հրատարակեց մի նշանավոր հոդված, որում նա ծրագրավորման համար արեց մի բան, ինչպիսին Էվկլիդեսն էր արել երկրաչափության համար։ Նա ցույց տվեց, թե ինչպես կարող ենք տրված պարզագույն գործողություններով և ֆունկցիաների համար գրառմամբ կառուցել ամբողջական ծրագրավորման լեզու։ Նա իր լեզուն անվանեց Լիսպ (Lisp - List Processing), որովհետև նրա հիմնական գաղափարներից մեկն այն էր, որ ծրագրերի և տվյալների համար օգտագործվի միակ տվյալների կառուցվածքը՝ ցուցակը։

It’s worth understanding what McCarthy discovered, not just as a landmark in the history of computers, but as a model for what programming is tending to become in our own time. Ինձ թվում է, որ մինչ այժմ գոյություն ունեն երկու իսկապես մաքուր ծրագրավորման մոդելներ. C մոդելը և Lisp մոդելը։ Այս երկուսը կարծես ճահճոտ ձորակով անջատված գագաթներ լինեն։ Երբ համակարգիչները սկսեցին ավելի հզորանալ, նոր մշակվող լեզուները սկսեցին անշեղորեն մոտենալ Լիսպ մոդելին։ Վերջին քսան տարիների ծրագրավորման լեզուներում մասսայական էր այն երևույթը, երբ ընտրվում էր հաշվարկման C մոդելը, ապա մաս առ մաս նրանում ավելացվում էր Լիսպ մոդելի տարրերը, ինչպիսիք են կատարման ժամանակ տիպերի դուրսբերումը (runtime typing) և աղբի հավաքումը (garbage collection)։ 

Այս հոդվածում ես ուզում պարզ տերմիններով եմ բացատրել այն, ինչ բացահայտել է ՄակՔարթին։ Նպատակս է ոչ միայն ծանոթացնել հետաքրքիր տեսական մի արդյունքի, որը ձևակերպվել է քառասուն տարի առաջ, այլև ցույց տալ, թե որտեղից են ծագում լեզուները։ Լիսպի ոչ սովորական հատկություններից մեկը, իսկ փաստացի՝ նրա որակական առանձնահատկությունը, այն է, որ Լիսպը կարող է իրականացվել Լիսպով։ Որպեսզի հասկանանք, թե ՄակՔարթին ինչ նկատի ուներ սրանով, մենք կկրկնենք նրա քայլերը՝ բայց փոխարինելով նրա օգտագործած մաթեմատիկական գրառումները Common Lisp լեզվով գրված կոդով։

## Յոթ տարրական գործողություններ

Սկսենք արտահայտությունների սահմանմամբ։ Արտահայտությունը կամ ատոմ է, որը տառերի հաջորդականություն է (օրինակ՝ foo), կամ զրո և ավելի արտահայտությունների ցուցակ է՝ տրոհված բացատանիշերով և պարփակված կլոր փակագծերում։ Ահա արտահայտությունների մի քանի օրինակներ.

````lisp
foo
()
(foo)
(foo bar)
(a b (c) d)
````

Վերջին արտահայտությունը չորս տարրերի ցուցակ է, որոնցից երրորդը իր հերթին մեկ տարր ունեցող ցուցակ է։

Թվաբանության մեջ 1 + 1 արտահայտության արժեքը 2 է։ Ճիշտ կառուցված Լիսպ արտահայտությունները նույնպես արժեք ունեն։ Եթե e արտահայտությունը հաշվարկվում է v արժեքի, ապա ասում ենք, որ e-ն վերադարձնում է v։ Մեր հաջորդ քայլն է սահմանել, թե ինչպիսի արտահայտություններ կարող են գոյություն ունենալ և դրանցից ամեն մեկն ինչ արժեք է վերադարձնում։

Եթե արտահայտությունը ցուցակ է, ապա նրա առաջին տարրն անվանում ենք գործողություն (operator), իսկ մյուսները՝ արգումենտներ։ Մենք պատրաստվում ենք սահմանել յոթ տարրական գործողություններ (ինչպիսին աքսիոմներն են). quote, atom, eq, car, cdr, cons և cond։

1. (quote x) — վերադարձնում է x։ Ընթեռնելիության համար (quote x) տեսքը կգրենք ‘x տեսքով։

````lisp
> (quote a)
a
> ’a
a
> (quote (a b c))
(a b c)
````

2. (atom x) — վերադարձնում է t ատոմը, եթե x-ի արժեքն ատոմ է կամ դատարկ ցուցակ։ Հակառակ դեպքում վերադարձնում է ()։ Լիսպ լեզվում t ատոմը պայմանականորեն օգտագործվում է ճշմարիտ արժեքի համար, իսկ դատարկ ցուցակը՝ կեղծ արժեքի։

````lisp
> (atom ’a)
t
> (atom ’(a b c))
()
> (atom ’())
t
````

Հիմա, երբ ունենք մի գործողություն, որի արգումենտը հաշվարկվում է, կարող ենք ցույց տալ, թե ինչի համար է quote գործողությունը։ Ցուցակի նկատմամբ quote-ը կիրառելով այն պաշտպանում ենք հաշվարկումից։ Որպես գործողության արգումենտ տրված և quote-ով չպաշտպանված ցուցակը մեկնաբանվում է որպես կոդ.

````lisp
> (atom (atom’a))
t
````

սակայն quote-ով պաշտպանված ցուցակը մեկնաբանվում է որպես սովորական ցուցակ, այս դեպքում, օրինակ, որպես երկու տարրեր պարունակող ցուցակ.

````lisp
> (atom ’(atom ’a))
()
````

Սա համապատասխանում է անգլերենում չակերտներօ օգտագործմանը։ Քեմբրիջը Մասաչուսեթս նահագի քաղաք է, որն ունի 90000 բնակիչ։ «Քեմբրիջ»-ը պարզապես յոթ տառ պարունակող բառ է։ quote-ը կարող է մի քիչ տարօրինակ թվալ, որովհետև շատ քիչ լեզուներում կա նման բան։ Այն սերտ կապված է Լիսպի ամենահատկանշական հատկություններից մեկի հետ. կոդը և տվյալները ներկայացվում են նույն տվյալների կառուցվածքով, և quote գործողությունը դրանք տարբերակելու եղանակն է։

3. (eq x y) — վերադարձնում է t, եթե x-ի և y-ի արժեքները նույն ատոմն են, կամ երկուսն էլ դատարկ ցուցակ են։ Հակառակ դեպքում վերադարձնում է ():

````lisp
> (eq ’a ’a)
t
> (eq ’a ’b)
()
> (eq ’() ’())
t
````

4. (car x) — սպասում է, որ x-ի արժեքը ցուցակ լինի և վերադարձնում է դրա առաջին տարրը։

````lisp
> (car ’(a b c))
a
````

5. (cdr x) — սպասում է, որ x-ի արժեքը ցուցակ լինի և վերադարձնում է առաջինից բացի մյուս տարրերի ցուցակը։

````lisp
> (cdr ’(a b c))
(b c)
````

6. (cons x y) — սպասում է, որ y-ի արժեքը ցուցակ լինի և վերադարձնում է մի ցուցակ, որի առաջին տարրը x-ի արժեքն է, իսկ հաջորդները՝ y-ի տարրերը։

````lisp
> (cons ’a ’(b c))
(a b c)
> (cons ’a (cons ’b (cons ’c ’())))
(a b c)
> (car (cons ’a ’(b c)))
a
> (cdr (cons ’a ’(b c)))
(b c)
````

7. (cond (p1 e1) . . . (pn en)) կառուցվածքը հաշվարկվում է հետևյալ կերպ։ Հերթականորեն հաշվարկվում են p արտահայտությունները, քանի դեռ նրանցից որևէ մեկը չի վերադարձրել t։ Եթե այդպիսի մեկը գտնվել է, ապա համապատասխան e արտահայտության արժեքը վերադարձվում է որպես ամբողջ cond արտահայտության արժեք։

````lisp
> (cond ((eq ’a ’b) ’first)
((atom ’a) ’second))
second
````

Մեր յոթ տարրական գործողություններից հինգում արգումենտները միշտ հաշվարկվում են, երբ այդ գործողությամբ արտահայտությունը հաշվարկվում է։ ?? Այդպիսի գործողությունը կանվանենք ֆունկցիա։

## Նշանակումներ ֆունկցիաների համար

Հաջորդիվ սահմանում ենք ֆունկցիաների գրառման եղանակը։ Ֆունկցիան գրառվում է (lambda (p1 . . . pn) e) տեսքով, որտեղ p1 . . . pn ատոմներ են (կոչվում են պարամետրեր) իսկ e-ն արտահայտություն է։ An expression whose first element is such an expression

````lisp
((lambda (p1 . . . pn) e) a1 . . . an)
````
