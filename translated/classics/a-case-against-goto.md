
# Ընդդեմ GO TO հրամանի

_Էդսգեր Դեյքսթրա_,

Այնդհովենի տեխնոլոգիական համալսարան, Նիդերլանդներ

Տարիների ընթացքում ես հանգել եմ այն կարծիքին, որ ծրագրավորողների որոկավորումը մի նվազող ֆունկցիա է՝ կախված նրանից, թե որքան հաճախ են նրանք իրենց ծրագրերում օգտագործում `go to` հրամանը։ Հետագայում ես հայտնաբերեցի, թե ինչու `go to` հրամանի օգտագործումն ունի այդպիսի աղետալի հետևանքներ և համոզված եմ, որ `go to` հրամանը պետք է հեռացնել բոլոր «բարձր մակարդակի» ծրագրավորման լեզուներից (այսինքն՝ ամեն տեղից, բացառությամբ, թերևս, միայն պարզ մեքենայական կոդի)։ Այն ժամանակ ես բավականաչափ ուշադրություն չդարձրեցի այս բացահայտմանը։ Բայց այս թեմայի վերաբերյալ վերջին քննարկումներն ինձ մղում են հրապարակել իմ նկատառումները։

Իմ առաջին դիտարկումն այն է, որ թեև ծրագրավորողի անելիքները վերջանում են ճիշտ աշխատող ծրագրի կառուցմամբ, նրա գործունեության իրական առարկան հենց ծրագրի ղեկավարությամբ աշխատող պրոցեսն է, այդ պրոցեսը պետք է ավարտվի նախապես որոշված արդյունքով, այդ պրոցեսի վարքը պետք է բավարարի տրված սահմանումներին։ Այնուհետև, հենց որ ծրագիրը «ստեղծված» է, համապատասխան պրոցեսի «ստեղծումը» հանձնարարվում է մեքենային։

Իմ երկրորդ դիտարկումը այն է, որ մեր մտավոր հնարավորությունները թեև բավարար են ստատիկ հարաբերությունները յուրացնելու համար, սակայն ժամանակի ընթաքում կատարվող պրոցեսները պատկերացնելու համար դրանք համեմատաբար թույլ են զարգացած։ Այդ պատճառով էլ մենք (ինչպես իրենց հնարավորությունները գիտակցող խելացի ծրագրավորողներ) պետք է ամեն հնարավորն անենք, որպեսզի կրճատենք ստատիկ ծրագի և դինամիկ պրոցեսի միջև եղած սկզբունքային բացը, որպեսզի ծրագրի (տեքստային տիրույթում որոշված) և պրոցեսի (ժամանակային տիրույթում որոշված) միջև եղած համապատասխանությունը դարձնենք որքան հնարավոր է պարզ։

Այժմ տեսնենք, թե ինչպես կարելի է բնութագրել պրոցեսի վիճակը։ (Դուք կարող եք այս հարցը պատկերացնել շատ կոնկրետ եղանակով՝ ենթադրելով, որ պրոցեսը որպես ժամանակի մեջ կատարվող գործողությունների հաջորդականություն, կանգ է առել որոշակի գործողությունից հետո։ Ի՞նչ տվյալներ պետք է ունենանք, որպեսզի կարողանանք կրկնել պրոցեսը և հասնել նույն այդ կետին։) Եթե ծրագիր տեքստը, ասենք, վերագրման հրամաների պարզ հերթագայություն է (այս քննարկման ենթատեքստում դրանք կդիտարկենք որպես պարզ գործողություններ), ապա բավական է ծրագրի տեքստում ցույց տալ երկու հաջորդական գործողությունների նկարագրության միջև կետը։ (`go to` հրամանի բացակայության դեպքում նակորդ նախադասության մեջ կարող եմ թույլ տալ շարահյուսական անմիարժեքություն․ եթե ասում ենք «հաջորդական (գործողությունների նկարագրություն), ապա նկատի ունենք տեքստային հաջորդում, իսկ եթե ասում ենք «(հաջորդական գործողությունների) նկարագրություն», ապա նկատի ունենք ժամանակային հաջորդում։) Տեքստում այս համապատասխան տեղը որոշող ցուցիչն անվանենք «տեքստային ինդեքս»։

Երբ ներմուծում ենք պայմանի հրամանը (`if B then A`), այլընտրանքի հրամանը (`if B then A1 else A2`), Հոարի առաջարկած ընտրության հրամանը (`case[i] of (A1, A2,.....,An`)) կամ ՄակՔարթիի առաջարկած պայմանական արտահայտությունները (`B1 → E1, B2 → E2,..., Bn → En`), պահպանվում է այն հատկությունը, որ պրոցեսի ընթացքը կարելի է բնութագրել միակ տեքստային ինդեքսով։

Հենց որ մեր լեզվում ներմուծում ենք պրոցեդուրաները, պետք է խոստովանենք, որ միակ տեքստային ինդեքսն այլևս բավարար չէ։ Այն դեպքում, երբ տեքստային ինդեքսը ցույց է տալիս պրոցեդուրայի մարմնի ներսը, դինամիկ պրոցեսը կարելի է բնութագրել միայն երբ նշում ենք նաև, թե պրոցեդուրայի որ կանչը նկատի ունենք։ Պրոցեդուրաների ներմուծմամբ կարող ենք պրոցեսի վիճակը բնութագրել տեքստային ինդեքսների հաջորդականությամբ։ Այդ հաջորդականության երկարությունը պետք է հավասար լինի պրոցեդուրաների կանչի դինամիկ խորությանը։

Հիմա դիտարկենք կրկնման հրամանները (ինչպիսիք են `while B repeat A` կամ `repeat A until B`)։ Տրամաբանորեն այս հրամաններն արդեն ավելորդ են, քանի որ կարող ենք կրկնությունն արտահայտել ռեկուրսիվ պրոցեդուրաների օգնությամբ։ Իրատեսության պատճառով ես չեմ ուզում բացառել դրանք․ մի կողմից՝ կրկնման հրամանները կարող է բավականին հաջող իրականացվել ժամանակակից սահմանափակ ապարատային հնարավորություններով, մյուս կողմից էլ` «ինդուկցիա» անունով փաստարկման մոդելը մեզ ստիպում է ավել լավ պատրաստվել կրկնման հրամաններով ծնված պրոցեսների ինտելեկտուալ ընկալման համար։ Կրկնման հրամանների ներմուծմամբ տեքստային ինդեքսները այլևս բավարար չեն դինամիկ պրոցեսների ընթացքը բնութագրելու համար։ Կրկնման հրամանի ամեն մի մուտքին, այնուամենայնիվ, կարող ենք համապատասխանեցնել այսպես կոչված «դինամիկ ինդեքս», որը ճշտորեն հաշվում է ընթացիկ կրկնության կարգաթիվը (հերթական համարը)։ Քանի որ կրկնման հրամանները (ինչպես նաև պրոցեդուրաների կանչերը) կարող են ներդրված լինել, պարզում ենք, որ այժմ պրոցեսի ընթացքը միշտ կարող է միարժեքորեն բնութագրվել տեքստային և/կամ դինամիկ ինդեքսների (խառը) հաջորդականությամբ։

Բանն այն է, որ այս ինդեքսների արժեքները ծրագրավորողի ղեկավարությունից դուրս են․ դրանք գեներացվում են անկախ նրա կամքից (գուցե ծրագիրը գրելիս, կամ գուցե պրոցեսը դինամիկ կատարվելիս)։ Դրանք ստեղծում են մի անխակ կոորդինատային համակարգ, որոնցով նկարագրվում է պրոցեսի ընթացքը։

Ինչո՞ւ է մեզ պետք այսպիսի անկախ կոորդինատները։ Պատճառն այն է, որ, and this seems to be inherent to sequential processes, փոփոխականի արժեքը կարող ենք մեկնաբանել միայն հաշվի առնելով պրոցեսի վիճակը։ Եթե ուզում ենք հաշվել, օրինակ, նախապես դատարկ սենյակում գտնվող մարդկանց _n_ թիվը, ապա դրան կարող ենք հասնել _n_֊ը _1_֊ով մեծացնելով ամեն անգամ, երբ տեսնում ենք սենյակ մտնող մարդու։ Այն միջանկյալ պահին, երբ տեսել ենք սենյակ մտնող մեկին, բայց դեռ _n_ չենք ավելացրել, _n_֊ի արժեքը հավասար է սենյակում գտվող մարդկանց քանակից հանած մեկ։

`go to` հրամանի անկաշկանդ (սանձարձակ, անհսկելի) օգտագործումն ունի այն անմիջական հետևանքը, որ ահավոր դժվար է դառնում որոշել կոորդինատների այն իմաստալից բազմությունը, որով նկարագրվում է պրոցեսի վիճակը։ Սովորաբար մարդիկ ուշադրության են առնում նաև որոշ առանձին ընտրված փոփոխականների արժեքներ, բայց դա էական չէ, անի որ դա կախված է այն վիճակից, որում պետք է հասկանալ այդ արժեքների իմաստը։ (??) `go to` հրամաններով էլ դեռ կարելի է, իհարկե, միարժեքորեն նկարագրել պրոցեսի վիճակը՝ օգտագորելով ծրագրի սկզբից կատարված գործողությունների մի հաշվիչ (այսինքն՝ նորմալիզացված ժամացույցի մի տեսակ)։ Դժվարությունն այն է, որ այդպիսի կոորդինատը, թեև եզակի է, սակայն բոլորովին անպետք է․ այդպիսի կոորդինատական համակարգում չափազանց դժվար գործ է դառնում սահմանել վիճակի բոլոր այն կետերը, որտեղ, ասենք, _n_֊ը հավասարվում է սենյակում գտնվող մարդկանց քանակից հանած մեկի։

`go to` հրամանն ինքնին շատ հասարակ է, այն ծրագիրը խճճելու բավականին մեծ գայթակղություն է առաջացնում։ Բերված դիտողությունները կարելի է գնահատել և հաշվի առնել որպես դրա կիրառումը զսպող գործոններ։ Ես չեմ պնդում, որ այստեղ բերված դիտարկումները սպառիչ են այն իմաստով, որ դրանք բավարարում են բոլոր պահանջներին։ Բայց ինչպիսի պահանջներ էլ որ դրվեն (օրինակ, դադարի պահանջը), դրանք պետք է բավարեն այն պայմանին, որ պետք է ապահովվեն ծրագրավորողից անկախ կոորդինատների համակարգ՝ պրոցեսը օգտակար ու կառավարելի նկարագրելու համար։

Դժվար է այս հոդվածն ավարտել առանց երախտիքի խոսքերի։ Կարո՞ղ եմ արդյոք ես դատել, թե ով է ազդել իմ դատողություների վրա։ Ակնհայտ է, որ ես անմասն չեմ մնացել Պիտեր Լանդինի (Peter Landin) և Քրիստոֆեր Ստրաչեյի (Christopher Strachey) ազդեցությունից։ (??) Վերջապես ուզում եմ նշել (դա ես բոլորովին հստակ հիշում եմ), թե ինչպես Հայնց Զեմանեկը (Heinz Zemanek) նախա֊ԱԼԳՈԼ֊ական քննարկումներում, 1959 թվականի սկզբներին Կոպենհագենում, բավականին հստակ արտահայտեց իր կասկածներն առ այն, թե արդյոք `go to` հրամանը պե՞տք է մեկնաբանել միևնույն շարահյուսական հիմունքներով, ինչպիսին վերագրման հրամանն է։ Ինչ֊որ չափով ինքս ինձ մեղադրում եմ նրանում, որ այն ժամանակ լիովին չպատկերացրեցի նրա դիտողությունների նշանակությունը։

`go to` հրամանի անցանկալի լինելու դիտարկումները նորություն չեն։ Հիշում եմ, որ կարդացել եմ `go to` հրամանի կիրառությունները վթարային ավարտով սահմանափակելու հստակ ցուցումներ, բայց չեմ հիշում, թե որտեղ հավանաբար դրա հեղինակը Հոարն է։ Վիրտը և Հոարը [1, Sec. 3.2.1] Wirth and Hoare together make a remark in the same direction in motivating the case construction: “Like the conditional, it mirrors the dynamic structure of a program more clearly than go to statements and switches, and it eliminates the need for introducing a large number of labels in the program.”

In [2] Guiseppe [sic] Jacopini seems to have proved the (logical) superfluousness of the go to statement. The exercise to translate an arbitrary flow diagram more or less mechanically into a jumpless one, however, is not to be recommended. Then the resulting flow diagram cannot be expected to be more transparent than the original one.

REFERENCES:

Wirth, Niklaus, and Hoare, C.A.R. A contribution to the development of ALGOL. Comm. ACM 9 (June 1966), 413–432.

Böhm, Corrado, and Jacopini, Guiseppe. Flow diagrams, Turing machines and languages with only two formation rules. Comm. ACM 9 (May 1966), 366–371. 


