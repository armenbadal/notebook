
# Ընդդեմ GO TO հրամանի

_Էդսգեր Դեյքսթրա_,

Այնդհովենի տեխնոլոգիական համալսարան, Նիդերլանդներ

(Թարգմանված է [EWD215](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD215.html)-ից)

Տարիների ընթացքում հանգել եմ այն կարծիքին, որ ծրագրավորողների որակավորումը մի նվազող ֆունկցիա է՝ կախված նրանից, թե որքան հաճախ են իրենց ծրագրերում օգտագործում `go to` հրամանը։ Հետագայում ես պարզեցի, թե ինչո՛ւ `go to` հրամանի օգտագործումն ունի այդպիսի աղետալի հետևանքներ և եկա այն համոզմունքին, որ `go to` հրամանը պետք է վերացնել բոլոր «բարձր մակարդակի» ծրագրավորման լեզուներից (այսինքն՝ ամեն տեղից, բացառությամբ, թերևս, միայն պարզ մեքենայական կոդի)։ Այն ժամանակ ես բավականաչափ ուշադրություն չդարձրեցի այս բացահայտմանը։ Բայց այս թեմայի վերաբերյալ վերջին քննարկումներն ինձ ստիպում են հրապարակել իմ նկատառումները։

Իմ առաջին դիտարկումն այն է, որ թեև ծրագրավորողի անելիքները վերջանում են ճիշտ աշխատող ծրագրի կառուցմամբ, նրա գործունեության իրական առարկան հենց ծրագրի ղեկավարությամբ աշխատող պրոցեսն է։ Այդ պրոցեսը պետք է ավարտվի նախապես որոշված արդյունքով, և այդ պրոցեսի դինամիկ վարքը պետք է բավարարի տրված սահմանումներին։ Այնուհետև, հենց որ ծրագիրը «ստեղծված» է, համապատասխան պրոցեսի «ստեղծումը» հանձնարարվում է մեքենային։

Իմ երկրորդ դիտարկումը այն է, որ մեր մտավոր հնարավորությունները թեև բավարար հարմարեցված են ստատիկ հարաբերությունները յուրացնելու համար, սակայն ժամանակի ընթաքում կատարվող պրոցեսները պատկերացնելու համար դրանք համեմատաբար թույլ են զարգացած։ Այդ պատճառով էլ մենք (ինչպես իրենց հնարավորությունները գիտակցող խելացի ծրագրավորողներ) պետք է ամեն հնարավորն անենք, որպեսզի կրճատենք ստատիկ ծրագրի և դինամիկ պրոցեսի միջև եղած սկզբունքային բացը, որպեսզի ծրագրի (տեքստային տիրույթում որոշված) և պրոցեսի (ժամանակային տիրույթում որոշված) միջև եղած համապատասխանությունը դարձնենք որքան հնարավոր է պարզ։

Այժմ տեսնենք, թե ինչպես կարելի է բնութագրել պրոցեսի ընթացքը։ (Դուք կարող եք այս հարցը պատկերացնել շատ կոնկրետ եղանակով՝ ենթադրելով, որ պրոցեսը որպես ժամանակի մեջ կատարվող գործողությունների հաջորդականություն, կանգ է առել որոշակի գործողությունից հետո։ Ի՞նչ տվյալներ պետք է ունենանք, որպեսզի կարողանանք կրկնել պրոցեսը և հասնել նույն այդ կետին։) Եթե ծրագիր տեքստը, օրինակ, վերագրման հրամաների պարզ հերթագայություն է (այս քննարկման ենթատեքստում դրանք կդիտարկենք որպես պարզ գործողություններ), ապա բավական է ծրագրի տեքստում նշել երկու հաջորդական գործողությունների սահմանման միջև կետը։ (`go to` հրամանի բացակայության դեպքում նախորդ նախադասության մեջ կարող եմ թույլ տալ շարահյուսական անմիարժեքություն․ եթե ասում ենք «հաջորդական (գործողությունների նկարագրություն), ապա նկատի ունենք տեքստային հաջորդում, իսկ եթե ասում ենք «(հաջորդական գործողությունների) նկարագրություն», ապա նկատի ունենք ժամանակային հաջորդում։) Տեքստում այս համապատասխան տեղը որոշող ցուցիչն անվանենք «տեքստային ինդեքս»։

Երբ ներառում ենք պայմանի հրամանը (`if B then A`), այլընտրանքի հրամանը (`if B then A1 else A2`), Չ. Հոարի առաջարկած ընտրության հրամանը (`case[i] of (A1, A2,.....,An`)) կամ ՄակՔարթիի առաջարկած պայմանական արտահայտությունները (`B1 → E1, B2 → E2,..., Bn → En`), պահպանվում է այն հատկությունը, որ պրոցեսի ընթացքը կարելի է բնութագրել միակ տեքստային ինդեքսով։

Հենց որ մեր լեզվում ներմուծում ենք պրոցեդուրաները, պետք է խոստովանենք, որ միակ տեքստային ինդեքսն այլևս բավարար չէ։ Այն դեպքում, երբ տեքստային ինդեքսը ցույց է տալիս պրոցեդուրայի մարմնում որևէ կետի, դինամիկ պրոցեսը կարելի է բնութագրել միայն երբ նշում ենք նաև, թե պրոցեդուրայի ո՛ր կանչը նկատի ունենք։ Պրոցեդուրաների ներմուծմամբ կարող ենք պրոցեսի վիճակը բնութագրել տեքստային ինդեքսների հաջորդականությամբ։ Այդ հաջորդականության երկարությունը պետք է հավասար լինի պրոցեդուրաների կանչի դինամիկ խորությանը։

Հիմա դիտարկենք կրկնման հրամանները (ինչպիսիք են `while B repeat A` կամ `repeat A until B`)։ Տրամաբանորեն այս հրամաններն արդեն ավելորդ են, քանի որ կարող ենք կրկնությունն արտահայտել ռեկուրսիվ պրոցեդուրաների օգնությամբ։ Իրատեսության պատճառով ես չեմ ուզում բացառել դրանք․ մի կողմից՝ կրկնման հրամանները կարող են բավականին հաջող իրականացվել ժամանակակից սահմանափակ ապարատային հնարավորություններով, մյուս կողմից էլ` «ինդուկցիա» անունով փաստարկման մոդելը մեզ ստիպում է ավել լավ պատրաստվել կրկնման հրամաններով ծնված պրոցեսների ինտելեկտուալ ընկալման համար։ Կրկնման հրամանների ներմուծմամբ տեքստային ինդեքսները այլևս բավարար չեն դինամիկ պրոցեսների ընթացքը բնութագրելու համար։ Կրկնման հրամանի ամեն մի մուտքին, այնուամենայնիվ, կարող ենք համապատասխանեցնել այսպես կոչված «դինամիկ ինդեքս», որը ճշտորեն հաշվում է ընթացիկ կրկնության կարգաթիվը (հերթական համարը)։ Քանի որ կրկնման հրամանները (ինչպես նաև պրոցեդուրաների կանչերը) կարող են ներդրված լինել, պարզում ենք, որ այժմ պրոցեսի ընթացքը միշտ կարող է միարժեքորեն բնութագրվել տեքստային և/կամ դինամիկ ինդեքսների (խառը) հաջորդականությամբ։

Բանն այն է, որ այս ինդեքսների արժեքները ծրագրավորողի հսկողությունից դուրս են․ դրանք գեներացվում են անկախ նրա կամքից (գուցե ծրագիրը գրելիս, կամ գուցե պրոցեսը դինամիկ կատարվելիս)։ Դրանք ստեղծում են մի անկախ կոորդինատային համակարգ, որոնցով նկարագրվում է պրոցեսի ընթացքը։

Ինչո՞ւ են մեզ պետք այսպիսի անկախ կոորդինատները։ Պատճառն այն է, և սա կարծես թե յուրահատուկ է հաջորդական պերոցեսներին, որ փոփոխականի արժեքը կարող ենք մեկնաբանել միայն հաշվի առնելով պրոցեսի վիճակը։ Եթե ուզում ենք հաշվել, օրինակ, նախապես դատարկ սենյակում գտնվող մարդկանց _n_ թիվը, ապա դրան կարող ենք հասնել _n_֊ը _1_֊ով մեծացնելով ամեն անգամ, երբ տեսնում ենք սենյակ մտնող մարդու։ Այն միջանկյալ պահին, երբ տեսել ենք սենյակ մտնող մեկին, բայց _n_-ը դեռ չենք ավելացրել, ապա _n_֊ի արժեքը հավասար է սենյակում գտվող մարդկանց քանակից հանած մեկ։

`go to` հրամանի անմիտ օգտագործումն ունի այն անմիջական հետևանքը, որ ահավոր դժվար է դառնում որոշել պրոցեսի վիճակը նկարագրող կոորդինատների իմաստալից բազմությունը։ Սովորաբար մարդիկ ուշադրության են առնում նաև որոշ առանձին ընտրված փոփոխականների արժեքներ, բայց դա էական չէ, քանի որ կախված է այն վիճակից, որում պետք է հասկանալ այդ արժեքների իմաստը։ ?? `go to` հրամաններով էլ դեռ կարելի է, իհարկե, միարժեքորեն նկարագրել պրոցեսի վիճակը՝ օգտագործելով ծրագրի սկզբից կատարված գործողությունների մի հաշվիչ (այսինքն՝ նորմալիզացված ժամացույցի մի տեսակ)։ Դժվարությունն այն է, որ այդպիսի կոորդինատը, թեև եզակի է, սակայն բոլորովին անպետք է․ այդպիսի կոորդինատական համակարգում չափազանց դժվար գործ է դառնում սահմանել վիճակի բոլոր այն կետերը, որտեղ, ասենք, _n_֊ը հավասարվում է սենյակում գտնվող մարդկանց քանակից հանած մեկի։

`go to` հրամանն ինքնին շատ հասարակ է, այն ծրագիրը խճճելու բավականին մեծ գայթակղություն է առաջացնում։ Բերված դիտողությունները կարելի է գնահատել և հաշվի առնել որպես դրա կիրառումը զսպող գործոններ։ Ես չեմ պնդում, որ այստեղ բերված դիտարկումները սպառիչ են այն իմաստով, որ դրանք բավարարում են բոլոր պահանջներին։ Բայց ինչպիսի պահանջներ էլ որ դրվեն (օրինակ, դադարի պահանջը), դրանք պետք է բավարեն այն պայմանին, որ կարելի է սահմանել ծրագրավորողից անկախ կոորդինատների համակարգ՝ պրոցեսը օգտակար ու կառավարելի նկարագրելու համար։

Դժվար է այս հոդվածն ավարտել առանց երախտիքի խոսքերի. կարո՞ղ եմ արդյոք ես դատել, թե ով է ազդել իմ դատողություների վրա։ Ակնհայտ է, որ ես անմասն չեմ մնացել Պիտեր Լանդինի (Peter Landin) և Քրիստոֆեր Ստրաչեյի (Christopher Strachey) ազդեցությունից։ Վերջապես ուզում եմ նշել (դա ես բոլորովին հստակ հիշում եմ), թե ինչպես Հայնց Զեմանեկը (Heinz Zemanek) նախա֊ԱԼԳՈԼ֊ական քննարկումներում, 1959 թվականի սկզբներին Կոպենհագենում, բավականին հստակ արտահայտեց իր կասկածներն առ այն, թե արդյոք `go to` հրամանը պե՞տք է մեկնաբանել միևնույն շարահյուսական հիմունքներով, ինչպիսին վերագրման հրամանն է։ Ինչ֊որ չափով ինքս ինձ մեղադրում եմ նրանում, որ այն ժամանակ լիովին չպատկերացրեցի նրա դիտողությունների նշանակությունը։

`go to` հրամանի անցանկալի լինելու դիտարկումները նորություն չեն։ Հիշում եմ, որ կարդացել եմ `go to` հրամանի կիրառությունները միայն վթարային ավարտի դեպքերով սահմանափակելու հստակ ցուցումների մասին, բայց չեմ հիշում, թե որտեղ. հավանաբար դրա հեղինակը Հոարն է։ Վիրտը և Հոարը, _A contribution to the development of ALGOL_ հոդվածի _3.2.1_ բաժնում, նույն նկատառումներն են անում՝ `case` կառուցվածքի մասին. «Ինչպես և պայմանական հրամանը, այն ծրագրի դինամիկ կառուցվածքն արտապատկերում է ավելի հստակ քան `go to` հրամանը կամ `switch` հրամանը, և այն հնարավորություն է տալիս հրաժարվել ծրագրում մեծ քանակությամբ պիտակներ ներկուծելուց»։

_Flow diagrams, Turing machines and languages with only two formation rules_ հոդվածում Ջուզեպպե Յակոպինին (Giuseppe Jacopini) ակնհայտորեն ապացուցել է `go to` հրամանի (տրամաբանական) ավելորդությունը։ Այնուամենայնիվ, կամայական կատարման գծապատկերի՝ բլոկ սխեմայի քիչ թե շատ մեխանիկական թարգմանությունը, առանց անպայման անցումների կոդի, խորհուրդ չի տրվում։ Այդ դեպքում չի կարելի ակնկալել, որ արդյունքում ստացված բլոկ-սխեման ավելի թափանցիկ է, քան սկզբնական տրվածը։

__Աղբյուրներ__

1. Wirth, Niklaus, and Hoare, C.A.R. A contribution to the development of ALGOL. Comm. ACM 9 (June 1966), 413–432.
2. Böhm, Corrado, and Jacopini, Guiseppe. Flow diagrams, Turing machines and languages with only two formation rules. Comm. ACM 9 (May 1966), 366–371.
